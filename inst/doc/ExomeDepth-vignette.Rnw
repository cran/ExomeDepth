\documentclass[10pt]{article}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}

%\VignetteIndexEntry{Using ExomeDepth}

\title{ExomeDepth}
\author{Vincent Plagnol}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\section{What ExomeDepth does and tips for QC}

\subsection{What ExomeDepth does and does not do}

ExomeDepth uses read depth data to call CNVs from exome sequencing experiments.
A key idea is that the test exome should be compared to a matched aggregate reference set.
This aggregate reference set should combine exomes from the same batch and it should also be optimized for each exome.
It will certainly differ from one exome to the next.

Importantly, ExomeDepth assumes that the CNV of interest is absent from the aggregate reference set.
Hence related individuals should be excluded from the aggregate reference.
It also means that ExomeDepth can miss common CNVs, if the call is also present in the aggregate reference.
ExomeDepth is really suited to detect rare CNV calls (typically for rare Mendelian disorder analysis).

The ideas used in this package are of course not specific to exome sequencing and could be applied to other targeted sequencing datasets, as long as they contain a sufficiently large number of exons to estimate the parameters (at least 20 genes, say, but probably more would be useful).
Also note that PCR based enrichment studies are often not well suited for this type of read depth analysis.
The reason is that as the number of cycles is often set to a high number in order to equalize the representation of each amplicon, which can discard the CNV information.


\subsection{Useful quality checks}
Just to give some general expectations I usually obtain 150-280 CNV calls per exome sample (two third of them deletions).
Any number clearly outside of this range is suspicious and suggests that either the model was inappropriate or that something went wrong while running the code.
Less important and less precise, I also expect the aggregate reference to contain 5-10 exome samples. 
While there is no set rule for this number, and the code may work very well with fewer exomes in the aggregate reference set, numbers outside of this range suggest potential technical artifacts.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Create count data from BAM files}

Firstly, to facilitate the generation of read count data,  exon positions for the hg19 build of the human genome are available within \texttt{ExomeDepth}.
This \texttt{exons.hg19} data frame can be directly passed as an argument of \texttt{getBAMCounts} (see below).

<<exons>>=
library(ExomeDepth)
data(exons.hg19)
print(head(exons.hg19))
@ 

To generate read count data, the function \texttt{getBamCounts} in \texttt{ExomeDepth} is set up to parse the BAM files. 
It generates an array of read count, stored in a GenomicRanges object.
It is a wrapper around the function \texttt{countBamInGRanges.exomeDepth} which is derived from an equivalent function in the \texttt{exomeCopy} package.
You can refer to the help page of \texttt{getBAMCounts} to obtain the full list of options. 
An example line of code (not evaluated here) would look like this:

<<read.count, eval=FALSE>>=
data(exons.hg19)
my.counts <- getBamCounts(bed.frame = exons.hg19,
                          bam.files = my.bam,
                          referenceFasta = fasta)
@ 

\texttt{my.bam} is a set character vector of indexed BAM files. 
\texttt{fasta} is the reference genome in fasta format (only useful if one wants to obtain the GC content).
\texttt{exons.hg19} are the positions and names of the exons on the hg19 reference genome (as shown above). 


\texttt{getBAMCounts} creates an object of the GRanges class which can easily be converted into a matrix or a data frame (which is the input format for \texttt{ExomeDepth}).
An example of GenomicRanges output generated by \texttt{getBAMCounts} is provided in this package (chromosome 1 only to keep the size manageable). 
Here is how this object could for example be used to obtain a more generic data frame:


<<Rsamtools.load>>=
library(ExomeDepth)
data(ExomeCount)
ExomeCount.dafr <- as(ExomeCount[,  colnames(ExomeCount)], 'data.frame')
ExomeCount.dafr$chromosome <- gsub(as.character(ExomeCount.dafr$space), 
                                        pattern = 'chr', 
                                        replacement = '')  ##remove the annoying chr letters
print(head(ExomeCount.dafr))
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Load an example dataset}
We have already loaded a dataset of chromosome 1 data for four exome samples.
We run a first test to make sure that the model can be fitted properly. 
Note the use of the subset.for.speed option that subsets some rows purely to speed up this computation.

<<first.test>>=
test <- new('ExomeDepth',
            test = ExomeCount.dafr$Exome2,
            reference = ExomeCount.dafr$Exome3,
            formula = 'cbind(test, reference) ~ 1',
            subset.for.speed = seq(1, nrow(ExomeCount.dafr), 100))

show(test)
@ 

\section{Build the most appropriate reference set}

Moving on toward a more useful computation, the first step is to select the most appropriate reference sample.
This step is demonstrated below.

<<reference.selection>>=
my.test <- ExomeCount$Exome4
my.ref.samples <- c('Exome1', 'Exome2', 'Exome3')
my.reference.set <- as.matrix(ExomeCount.dafr[, my.ref.samples])
my.choice <- select.reference.set (test.counts = my.test, 
                                   reference.counts = my.reference.set, 
                                   bin.length = (ExomeCount.dafr$end - ExomeCount.dafr$start)/1000, 
                                   n.bins.reduced = 10000)

print(my.choice[[1]])
@ 

Using the output of this procedure we can construct the reference set.
<<construct.ref>>=
my.reference.selected <- apply(X = as.matrix( ExomeCount.dafr[, my.choice$reference.choice] ), 
                               MAR = 1, 
                               FUN = sum)
@ 


\section{CNV calling}
Now the following step is the longest one as the beta-binomial model is applied to the full set of exons:
<<build.complete>>=
all.exons <- new('ExomeDepth',
                 test = my.test,
                 reference = my.reference.selected,
                 formula = 'cbind(test, reference) ~ 1')
@ 


We can now call the CNV by running the underlying hidden Markov model:
<<call.CNVs>>=
all.exons <- CallCNVs(x = all.exons, 
                      transition.probability = 10^-4, 
                      chromosome = ExomeCount.dafr$space, 
                      start = ExomeCount.dafr$start, 
                      end = ExomeCount.dafr$end, 
                      name = ExomeCount.dafr$names)
print(head(all.exons@CNV.calls))
@ 


\section{A visual example}

The ExomeDepth object includes a plot function. This function shows the ratio between observed and expected read depth.
The 95\% confidence interval is marked by a grey shaded area.
Here we use a common CNV located in the \texttt{RHD} gene as an example. 
We can see that the individual in question has more copies than the average (in fact two functional copies of RHD, which corresponds to rhesus positive).

<<fig = TRUE, echo = TRUE>>=
plot (all.exons,
      sequence = '1',
      xlim = c(25598981 - 100000, 25633433 + 100000),
      count.threshold = 20,
      main = 'RHD gene',
      with.gene = TRUE)
@ 

\section{Technical information about R session}

<<session>>=
sessionInfo()
@ 



\end{document}
