\documentclass[10pt]{article}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}

%\VignetteIndexEntry{Using ExomeDepth}

\title{ExomeDepth}
\author{Vincent Plagnol}
\date{\today}

\begin{document}
\maketitle

\tableofcontents


\section{Create count data from BAM files}

Firstly, to facilitate the generation of read count data,  exon positions for the hg19 build of the human genome are available within \texttt{ExomeDepth}.
This \texttt{exons.hg19} data frame can be directly passed as an argument of \texttt{getBAMCounts} (see below).

<<exons>>=
library(ExomeDepth)
data(exons.hg19)
print(head(exons.hg19))
@ 

To generate read count data, the function \texttt{getBamCounts} in \texttt{ExomeDepth} is set up to parse the BAM files. 
It generates an array of read count, stored in a GenomicRanges object.
It is a wrapper around the function \texttt{countBamInGRanges.exomeDepth} which is derived from an equivalent function in the \texttt{exomeCopy} package.
You can refer to the help page of \texttt{getBAMCounts} to obtain the full list of options. 
An example line of code (not evaluated here) would look like this:

<<read.count, eval=FALSE>>=
data(exons.hg19)
my.counts <- getBamCounts(bed.frame = exons.hg19,
                          bam.files = my.bam,
                          referenceFasta = fasta)
@ 

\texttt{my.bam} is a set character vector of indexed BAM files. 
\texttt{fasta} is the reference genome in fasta format (only useful if one wants to obtain the GC content).
\texttt{exons.hg19} are the positions and names of the exons on the hg19 reference genome (as shown above). 


\texttt{getBAMCounts} creates an object of the GRanges class which can easily be converted into a matrix or a data frame (which is the input format for \texttt{ExomeDepth}).
An example of GenomicRanges output generated by \texttt{getBAMCounts} is provided in this package (chromosome 1 only to keep the size manageable). 
Here is how this object could for example be used to obtain a more generic data frame:


<<Rsamtools.load>>=
library(ExomeDepth)
data(ExomeCount)
ExomeCount <- as(ExomeCount[,  colnames(ExomeCount)], 'data.frame')
ExomeCount$chromosome <- gsub(as.character(ExomeCount$space), 
                              pattern = 'chr', 
                              replacement = '')  ##remove the annoying chr letters
print(head(ExomeCount))
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Load an example dataset}
We have already loaded a dataset of chromosome 1 data for four exome samples.
We run a first test to make sure that the model can be fitted properly. 
Note the use of the subset.for.speed option that subsets some rows purely to speed up this computation.

<<first.test>>=
test <- new('ExomeDepth',
            test = ExomeCount$Exome2,
            reference = ExomeCount$Exome3,
            formula = 'cbind(test, reference) ~ 1',
            subset.for.speed = seq(1, nrow(ExomeCount), 100))

show(test)
@ 

\section{Build the most appropriate reference set}

Moving on toward a more useful computation, the first step is to select the most appropriate reference sample.
This step is demonstrated below.

<<reference.selection>>=
my.test <- ExomeCount$Exome4
my.ref.samples <- c('Exome1', 'Exome2', 'Exome3')
my.reference.set <- as.matrix(ExomeCount[, my.ref.samples])
my.choice <- select.reference.set (test.counts = my.test, 
                                   reference.counts = my.reference.set, 
                                   bin.length = (ExomeCount$end - ExomeCount$start)/1000, 
                                   n.bins.reduced = 10000)

print(my.choice[[1]])
@ 

Using the output of this procedure we can construct the reference set.
<<construct.ref>>=
my.reference.selected <- apply(X = as.matrix( ExomeCount[, my.choice$reference.choice] ), 
                               MAR = 1, 
                               FUN = sum)
@ 


\section{CNV calling}
Now the following step is the longest one as the beta-binomial model is applied to the full set of exons:
<<build.complete>>=
all.exons <- new('ExomeDepth',
                 test = my.test,
                 reference = my.reference.selected,
                 formula = 'cbind(test, reference) ~ 1')
@ 


We can now call the CNV by running the underlying hidden Markov model:
<<call.CNVs>>=
all.exons <- CallCNVs(x = all.exons, 
                      transition.probability = 10^-4, 
                      chromosome = ExomeCount$space, 
                      start = ExomeCount$start, 
                      end = ExomeCount$end, 
                      name = ExomeCount$names)
print(head(all.exons@CNV.calls))
@ 


\section{A visual example}

The ExomeDepth object includes a plot function. This function shows the ratio between observed and expected read depth.
The 95\% confidence interval is marked by a grey shaded area.
Here we use a common CNV located in the \texttt{RHD} gene as an example. 
We can see that the individual in question has more copies than the average (in fact two functional copies of RHD, which corresponds to rhesus positive).

<<fig = TRUE, echo = TRUE>>=
plot (all.exons,
      sequence = '1',
      xlim = c(25598981 - 100000, 25633433 + 100000),
      count.threshold = 20,
      main = 'RHD gene',
      with.gene = TRUE)
@ 

\section{Technical information about R session}

<<session>>=
sessionInfo()
@ 



\end{document}
